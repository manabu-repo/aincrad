---
title: "React Interview Points"
description: "React Interview Points(React 面试要点)"
publishDate: "7 Mar 2025"
updatedDate: "10 Mar 2025"
tags: ["post", "interview"]
---

## 基础部分

1. `JSX`

- 什么是`JSX`?
> JSX 是一种语法扩展，它允许在 JavaScript 中使用 HTML-like 的语法来描述 UI。

- 它是如何工作的?
> JSX 会被 Babel 编译成 React.createElement 函数调用，该函数会返回一个 React 元素对象。

- 为什么使用 JSX?
> JSX 提供了一种更直观、更简洁的方式来描述 UI 并且可以与 JavaScript 代码无缝集成。

2. `React` 的特点
> React 是一个用于构建用户界面的 JavaScript 库。特点包括：组件化、虚拟`DOM`、单向数据流、声明式编程、`JSX`、生命周期、`Hooks`等。

- **组件化：** 将页面拆分成多个小的、可复用的组件，每个组件有自己的职责和状态，提高代码的可维护性和复用性。
- **虚拟`DOM`**: `React` 引入虚拟 `DOM` 作为真实 `DOM` 的抽象表示，通过对比虚拟 `DOM` 的差异，只更新需要更新的真实 `DOM` 部分，减少 `DOM` 操作，提高性能。
- **单向数据流：** 数据的流动是单向的，易于理解和调试，数据的变化会触发视图的更新，但视图的变化不会直接修改数据。
- **声明式编程：** 通过声明式的语法描述 `UI` 的外观和行为，代码更简洁、易读。

3. `React` 的生命周期（类组件）

- `constructor()`
- `static getDerivedStateFromProps()`
- `render()`
- `componentDidMount()`
- `shouldComponentUpdate()`
- `getSnapshotBeforeUpdate()`
- `componentDidUpdate()`
- `componentWillUnmount()`

4. `Hooks`（函数组件）

- `useState()`
- `useEffect()`
- `useContext()`
- `useReducer()`
- `useCallback()`
- `useMemo()`
- `useRef()`
- `useImperativeHandle()` 与 `forwardRef()`
- `useLayoutEffect()`
- `useDebugValue()`

5. `Context API`

- `React.createContext()`
- `Context.Provider`
- `Context.Consumer`
- `useContext()`

6. `Refs`

- `React.createRef()`
- `ref` 属性
- `useRef()`

7. `PropTypes`

- `PropTypes.string` 与 `PropTypes.number` 与 `PropTypes.bool` 与 `PropTypes.func` 与 `PropTypes.array` 与 `PropTypes.object` 与 `PropTypes.node` 与 `PropTypes.element`
- `PropTypes.instanceOf()`
- `PropTypes.oneOf()` 与 `PropTypes.oneOfType()`
- `PropTypes.shape()`
- `PropTypes.exact()`

8. 组件

组件是 `React` 应用的基本构建块,它可以将页面拆分成多个独立的、可复用的部分。可以是类组件或函数组件。

- 函数组件：也称为无状态组件，是一个纯函数，接收 `props` 作为参数，返回一个 `React` 元素。没有自己的状态和生命周期方法。优点是简单易维护

- 类组件：有状态组件,通过 `class` 关键字定义,继承自 `React.Componet` 有自己的状态和生命周期方法，可以处理更复杂的逻辑，可以访问`this`关键字。

9. 如何优化 `React` 应用性能？

- 使用 `shouldComponentUpdate` 或 `React.memo`：在类组件中，可以使用 `shouldComponentUpdate` 生命周期方法来控制组件是否需要重新渲染；在函数组件中，可以使用 `React.memo` 来包裹组件，对组件进行浅比较，避免不必要的渲染。

- 使用 `React.lazy` 和 `Suspense` 进行代码分割：对于大型应用，可以将代码分割成多个小块，使用 `React.lazy` 动态加载组件，`Suspense` 用于在组件加载时显示加载提示，减少初始加载时间。

- 优化 `CSS`：避免使用内联样式，使用 `CSS` 类名，减少 `DOM` 操作和重排。

- 使用 `useCallback` 和 `useMemo`：在函数组件中，`useCallback` 用于缓存函数，`useMemo` 用于缓存计算结果，避免不必要的函数创建和计算。

10. 虚拟 `DOM` 如何提高性能

- 减少 `DOM` 操作：虚拟`DOM`通过在内存中进行比较，找出需要更新的部分，会将多次操作合并成一次，然后批量更新到真实 `DOM`，减少了 `DOM` 操作次数。

- 批量更新：`React` 会将多个 `setState` 调用合并成一个更新，以减少不必要的重渲染。减少浏览器的重排和重绘次数，提高了性能

- 高效的 `Diff` 算法：通过对比新旧虚拟 `DOM` 的差异，快速找出需要更新的部分，提高了比较的效率。

11. `React` 中的事件机制

- 事件冒泡：事件从触发元素开始，逐级向上传播到根元素的过程。
- 事件捕获：事件从根元素开始，逐级向下传播到触发元素的过程。
- 事件委托：将事件监听器绑定在父元素上，利用事件冒泡机制，通过判断事件的目标元素来处理事件。
- 事件代理：将事件监听器绑定在父元素上，通过事件冒泡机制，通过判断事件的目标元素来处理事件。

12. `React` 中的 `key` 属性

> `key` 属性用于帮助 React 识别列表中的每个元素，以便在更新列表时能够正确地识别新增、删除、移动的元素。

13. `React` 中的 `ref` 属性

> `ref` 属性用于获取组件的实例或元素节点，用于访问组件内部状态和操作组件。

14. `React` 中的 `Fragment`

> `Fragment` 是一个特殊的组件，用于将多个元素组合成一个虚拟的父元素，避免在渲染时生成额外的 DOM 元素。

15. `React` 中的 `Portal`

> `Portal` 是一种将子组件渲染到其他 DOM 元素上的方式，用于解决组件层级问题，比如将弹出框渲染到页面的根元素上。

16. `React` 中的状态管理方式

- `useState`：用于在函数组件中管理状态。适用于组件内部的简单状态管理，数据只在组件内部使用，不需要共享。
- `useReducer`：用于在函数组件中管理状态，使用 `reducer` 函数来处理状态更新。
- `提升状态`：当多个组件需要共享状态时，可以将状态提升到它们的共同父组件中，通过 props 传递数据和回调函数。
- `Context API`：用于在组件树中共享状态，通过 `Provider` 和 `Consumer` 来传递数据。
- `Redux`：用于管理应用的全局状态，通过 `store` 来管理状态，使用 `action` 和 `reducer` 来更新状态。
- `MobX`：用于管理应用的全局状态，通过 `observable` 和 `action` 来管理状态，通过 `reaction` 来响应状态的变化。

17. `React Router` 有哪些类型的路由？

- `BrowserRouter`：用于创建一个浏览器环境下的路由，使用 `HTML5` 的 `history API`(`pushState`、`replaceState` 和 `popstate` 事件)来管理路由，适用于现代浏览器，`URL` 看起来更自然，没有哈希符号。
- `HashRouter`：用于创建一个 `URL` 的哈希值（`hash`）环境下的路由，使用 URL 的哈希值来表示路由。
- `MemoryRouter`：用于创建一个内存中的路由，用于测试和开发环境。
- `StaticRouter`：用于创建一个静态的 `URL` 路由，用于生产环境。
- `NativeRouter`：用于创建一个 `React Native` 的路由，用于移动端开发。

18. `React Router` 如何实现路由守卫？

- `Route` 组件的 `render` 属性：可以在 `render` 属性中添加条件判断，根据条件渲染不同的组件。
- `Redirect` 组件：用于重定向到其他路由，可以用于实现登录验证和权限控制。
- `withRouter` 高阶组件：用于将路由信息传递给组件，可以在组件中访问路由信息。
- `PrivateRoute` 自定义组件实现：用于实现私有路由，根据用户是否登录，显示不同的组件。

```jsx
import { Route, Redirect, withRouter } from 'react-router-dom';

function PrivateRoute({ component: Component, authenticated, ...rest }) {
  return (
    <Route
      {...rest}
      render={(props) =>
        authenticated ? (
          <Component {...props} />
        ) : (
          <Redirect to="/login" />
        )
      }
    />
  );
}

export default withRouter(PrivateRoute);
```

19. `React Router` 如何实现路由懒加载？

- `React.lazy`：用于动态加载组件，可以结合 `Suspense` 组件一起使用，实现路由懒加载。
- `Suspense`：用于在组件加载时显示加载提示，可以结合 `React.lazy` 一起使用，实现路由懒加载。

```jsx
import React, { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

function LazyRoute() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

## 核心机制

1. 虚拟`DOM`与`Diff`算法

- 虚拟`DOM`：`React` 通过在内存中构建虚拟的`DOM`树来提高性能，减少`DOM`操作和重排。
- `Diff`算法：通过对比新旧虚拟`DOM`的差异，快速找出需要更新的部分，以提高比较的效率。

`Diff`算法的过程(**`TODO`**)

2. `useMemo` 与 `useCallback`

- `useMemo`：用于缓存计算结果，避免不必要的计算。
- `useCallback`：用于缓存函数，避免不必要的函数创建。

如何使用 `useMemo` 和 `useCallback`?

```jsx
import React, { useMemo, useCallback } from 'react';

function MyComponent({ data }) {
  const memoizedValue = useMemo(() => computeExpensiveValue(data), [data]);
  const memoizedCallback = useCallback(() => {
    doSomething(data);
  }, [data]);

  return (
    <div>
      <div>{memoizedValue}</div>
      <button onClick={memoizedCallback}>Click me</button>
    </div>
  );
}
```

3. `useReducer` 与 `useContext`

- `useReducer`：用于在函数组件中管理状态，使用 `reducer` 函数来处理状态更新。
- `useContext`：用于在函数组件中获取 `Context` 的值。

如何使用 `useReducer`?

```jsx
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <div>
      Count: {state.count}
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </div>
  );
}

export default Counter;
```

4. `Fiber` 架构与异步渲染

- `Fiber` 架构：`React` 16 中引入的新的协调引擎，用于实现增量式更新，提高渲染性能。
- 异步渲染：`React` 16 中引入的新特性，用于将渲染工作分片处理，避免阻塞主线程，提高用户体验。

解释 Fiber 架构的工作原理(**`TODO`**)

5. `Hooks` 实现原理

- `Hooks` 是 `React` 16.8 中引入的新特性，用于在函数组件中使用状态和生命周期方法。
- `Hooks` 的实现原理是通过链表的方式来保存组件的状态和副作用，通过 `Hooks` 的调用顺序来保证状态的正确更新。
- 常用`Hooks` 包括 `useState` 和 `useEffect` 等 `Hooks` 来实现状态和副作用的保存和获取， `useReducer` 来实现状态的更新。

6. `React Server Components` 服务端渲染(`RSC`)

- 服务端渲染（`Server Side Rendering`,`SSR`）是指在服务器上渲染 `React` 应用，然后将渲染后的 `HTML` 返回给客户端，客户端再渲染。
- 服务端渲染的优点是首次加载速度更快，`SEO` 更好，用户体验更好。
- 服务端渲染的缺点是服务器需要处理更多的请求，需要更多的内存和 `CPU` 资源。
- `React` 提供了 `ReactDOMServer` 模块，用于在服务器上渲染 `React` 应用。

## 状态管理与数据流

1. 状态提升与`Context API`

- 状态提升：将多个组件共享的状态提升到它们的共同父组件中，通过 `props` 传递数据和回调函数。
- `Context API`：用于在组件树中共享状态，通过 `Provider` 和 `Consumer` 来传递数据。

如何定义和使用 `Context API`?

```jsx
import React, { createContext, useContext } from 'react';
const ThemeContext = createContext();
function ThemeProvider({ children }) {
  const theme = 'dark';
  return <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>;
}
function ThemeComponent() {
  const theme = useContext(ThemeContext);
  return <div>Theme: {theme}</div>;
}
```

消费 `Context` 的两种方式：`Consumer` 和 `useContext`。

在类组件中，我们也可以选择使用 `Consumer`:

```jsx
function ThemeComponent() {
  return (
    <ThemeContext.Consumer>
      {(theme) => <div>Theme: {theme}</div>}
    </ThemeContext.Consumer>
  );
}
```

2. `Redux`与`MobX`

`Redux` 是一个用于管理 `React` 应用状态的可预测状态容器，其工作原理如下：

- 单一数据源：应用的所有状态都存储在一个单一的 `store` 中，方便管理和调试。

- `Action`：是一个描述状态变化的对象，包含一个 `type` 属性和可选的 `payload` 属性。组件通过 `dispatch` 方法发送 `action` 到 `store`。

- `Reducer`：是一个纯函数，接收当前状态和 `action` 作为参数，返回一个新的状态。`store` 会根据 `action` 调用相应的 `reducer` 来更新状态。

- 订阅与更新：组件可以订阅 `store` 的变化，当状态发生变化时，`store` 会通知所有订阅的组件，组件可以获取新的状态并更新视图。

## 性能优化

1. 避免不必要的渲染

- 使用 `React.memo` 或 `PureComponent` 来避免不必要的渲染。
- 使用 `shouldComponentUpdate` 或 `React.memo` 的第二个参数来避免不必要的渲染。
- 使用 `useMemo` 和 `useCallback` 来避免不必要的计算和渲染。
- 使用 `React.StrictMode` 来检测不推荐的用法，如使用过时或不推荐使用的 API。

2. 代码分割与懒加载

- 使用 `React.lazy` 和 `Suspense` 来实现代码分割和懒加载。
- 将应用拆分成多个小块，按需加载，减少初始加载时间。
- 使用 `webpack` 的 `SplitChunksPlugin` 来将公共代码提取成单独的文件。
- 使用 `import()` 语法来实现动态导入。

## 项目实战与设计

### 复杂组件设计

1. 设计一个支持万级数据量的高性能表格组件

- 使用虚拟加载技术()，只渲染可视区域内的数据(元素)
- 分页或懒加载数据，避免一次性渲染全部内容
- 使用 `useMemo` 缓存计算密集型操作(如排序/过滤)

更多：

- 使用 `useCallback` 缓存函数
- 使用 `React.memo` 或 `useMemo` 缓存组件

2. 设计一个支持拖拽排序的列表组件

- 使用 `react-dnd` 或 `react-beautiful-dnd` 等库实现拖拽功能
- 使用 `useState` 或 `useReducer` 管理组件状态
- 使用 `useEffect` 处理拖拽结束后的数据更新

### 错误处理与监控

- 使用 `try...catch` 语句处理错误
- 使用 `console.error` 或 `console.warn` 记录错误信息
- 使用 `window.onerror` 或 `window.onunhandledrejection` 监听全局错误信息

## `Next.js`相关

(**`TODO`**)

## 测试 (`Jest` 与 `React Testing Library`)

1. 单元测试

如何使用 `React Testing Library` 进行单元测试？

```jsx
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import MyComponent from './MyComponent';

test('renders MyComponent', () => {
  render(<MyComponent />);
  expect(screen.getByText('Hello, world!')).toBeInTheDocument();
});
```

2. 组件测试

如何测试组件的状态、事件和异步操作？

```jsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import MyComponent from './MyComponent';

test('updates state on button click', () => {
  render(<MyComponent />);
  fireEvent.click(screen.getByText('Click me'));
  expect(screen.getByText('Clicked')).toBeInTheDocument();
});

test('fetches data on mount', async () => {
  render(<MyComponent />);
  await waitFor(() => expect(screen.getByText('Data fetched')).toBeInTheDocument());
})
```

- 查询元素方法

  - `screen.getByText`：根据文本内容查询元素
  - `screen.getByRole`：根据角色查询元素
  - `screen.getByTestId`：根据 `data-testid` 属性查询元素
  - `screen.getByLabelText`：根据 `label` 标签查询元素
  - `screen.getByPlaceholderText`：根据占位符文本查询元素

- 断言元素状态方法

  - `toBeInTheDocument`：元素是否在文档中
  - `toBeVisible`：元素是否可见
  - `toHaveTextContent`：元素文本内容是否匹配
  - `toHaveValue`：元素值是否匹配
  - `toHaveAttribute`：元素属性是否匹配

- 事件触发方法（模拟用户操作方法）

  - `fireEvent.click`：模拟点击事件
  - `fireEvent.change`：模拟输入事件
  - `fireEvent.submit`：模拟提交事件
  - `fireEvent.keyDown`：模拟键盘按下事件

- 异步操作方法

  - `waitFor`：等待某个条件成立时，继续执行后续代码
  - `waitForElementToBeRemoved`：等待某个元素被移除时，继续执行后续代码
  - `act`：用于模拟 React 更新流程，通常在测试中用于更新组件、触发事件等操作。
  - `flushSync`：用于同步更新组件，通常在测试中用于更新组件、触发事件等操作。

## React 18+ 新特性

### `Concurrent Mode` 并发模式

> Concurrent Mode 是 React 18 的新特性，它允许 React 在同一帧内完成多个更新，从而提高性能。

### 并发API `startTransition` 和 `useDeferredValue`

> `startTransition` 用于启动一个优先级较低的更新，以减少对用户交互的影响。`useDeferredValue` 用于延迟更新，以减少对性能的影响。

### `Suspense` 与 `lazy`、`SuspenseList`

> `Suspense` 用于在组件加载时显示加载提示，`lazy` 用于动态加载组件，`SuspenseList` 用于按顺序显示多个加载提示。

### 自动批处理 `Automatic Batching`

> 自动批处理指的是 React 会将多个 `setState` 调用合并成一个更新，以减少不必要的重渲染。

## React生态与工具

### react-router

基本使用：

```jsx
import React from 'react';
import { BrowserRouter as Router, Route, Switch, Redirect, withRouter } from 'react-router-dom';

function PrivateRoute({ component: Component, ...rest }) {
  return (
    <Route
      {...rest}
      render={(props) =>
        localStorage.getItem('token') ? (
          <Component {...props} />
        ) : (
          <Redirect to="/login" />
        )
      }
    />
  );
}

function App() {
  return (
    <Router>
      <Switch>
        <Route exact path="/" component={Home} />
        <PrivateRoute path="/dashboard" component={Dashboard} />
        <Route path="/login" component={Login} />
      </Switch>
    </Router>
  );
}
```

1. `BrowserRouter`：用于创建一个浏览器路由，用于网页开发。
2. `HashRouter`：用于创建一个哈希路由，用于单页应用开发。
3. `NativeRouter`：用于创建一个 React Native 的路由，用于移动端开发。
4. `MemoryRouter`：用于创建一个内存路由，用于测试和开发环境。
5. `Route`：用于定义路由规则，用于匹配 URL 并渲染对应的组件。
6. `Link`：用于创建一个链接，用于跳转到指定的路由。
7. `Switch`：用于匹配路由规则，只渲染第一个匹配的组件。
8. `Redirect`：用于重定向到其他路由。
9. `withRouter`：用于获取路由信息，用于在组件中获取路由信息。
10. `useHistory`：用于获取路由历史信息，用于在函数组件中获取路由信息。
11. `useLocation`：用于获取当前路由信息，用于在函数组件中获取当前路由信息。
12. `useParams`：用于获取路由参数，用于在函数组件中获取路由参数。
13. `useRouteMatch`：用于获取路由匹配信息，用于在函数组件中获取路由匹配信息。
14. `useRoutes`：用于匹配路由规则，用于在函数组件中匹配路由规则。

### react-redux

1. 定义 `action` 和 `reducer`

> action 是一个描述状态变化的对象，包含一个 `type` 属性和可选的 `payload` 属性。

> reducer 是一个纯函数，接收当前状态和 action 作为参数，返回一个新的状态。

```jsx
// 定义 action
const increment = () => ({ type: 'INCREMENT' });
const decrement = () => ({ type: 'DECREMENT' });

// 定义 reducer
const counterReducer = (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    default:
      return state;
  }
}
```

2. 创建 `store`

> store 是一个用于管理应用状态的容器，包含应用的所有状态和 reducer。

```jsx
import { createStore, combineReducers, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(combineReducers({ counter: counterReducer }), applyMiddleware(thunk));

// 简单创建
// const store = createStore(counterReducer);
```

- `combineReducers`：用于将多个 `reducer` 合并成一个 `reducer`。
- `applyMiddleware`：用于应用中间件，中间件可以用于处理异步操作、日志记录等。
- `thunk`：用于处理异步操作，可以用于发送 `AJAX` 请求、处理 `Promise` 等。

3. 在 `React` 组件中使用

- 在类组件中使用：

> 使用 `connect` 函数将组件连接到 `store`，通过 `mapStateToProps` 和 `mapDispatchToProps` 映射状态和操作到组件的 `props`。

```jsx
import { connect } from 'react-redux';
import React from 'react';
import { increment, decrement } from './actions';

const Counter = ({ count, increment, decrement }) => {
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
};

const mapStateToProps = (state) => ({
  count: state.counter.count,
});

const mapDispatchToProps = (dispatch) => ({
  increment: () => dispatch(increment()),
  decrement: () => dispatch(decrement()),
});

export default connect(mapStateToProps, mapDispatchToProps)(Counter);
```

- 在函数组件中使用：

> 使用 `useSelector` 和 `useDispatch` 钩子来获取状态和操作。

- `useSelector`：用于获取状态。
- `useDispatch`：用于获取操作。

```jsx
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './actions';

const Counter = () => {
  const count = useSelector(state => state.counter.count);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>Increment</button>
      <button onClick={() => dispatch(decrement())}>Decrement</button>
    </div>
  );
};

export default Counter;
```

完整使用例子：

```jsx
import React from 'react';
import { createStore, combineReducers, applyMiddleware } from 'redux';
import { Provider, connect } from 'react-redux';
import thunk from 'redux-thunk';

// 定义 reducer
const counterReducer = (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    default:
      return state;
  }
};

// 创建 store
const store = createStore(combineReducers({ counter: counterReducer }), applyMiddleware(thunk));

// 定义组件
const Counter = ({ count, increment, decrement }) => {
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
};

// 连接组件和 store
const ConnectedCounter = connect((state => ({ count: state.counter.count })), dispatch => ({
  increment: () => dispatch({ type: 'INCREMENT' }),
  decrement: () => dispatch({ type: 'DECREMENT' }),
}))(Counter);

// 定义组件
const App = () => {
  return (
    <Provider store={store}>
      <ConnectedCounter />
    </Provider>
});
```

### zustand

基本使用：

```jsx
import create from 'zustand';

const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

const Counter = () => {
  const { count, increment, decrement } = useStore();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
};

const App = () => {
  return <Counter />;
};
```
### react-query

基本使用：

```jsx
import React from 'react';
import { useQuery } from 'react-query';

const fetchData = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/todos/1');
  return res.json();
};

const App = () => {
  const { data, isLoading, isError } = useQuery('todo', fetchData);

  if (isLoading) return <p>Loading...</p>;
  if (isError) return <p>Error :(</p>;

  return <p>{data.title}</p>;
};
```
